From af824dc552c4903b9b17221a06a1350d96e41235 Mon Sep 17 00:00:00 2001
From: Matti Picus <matti.picus@gmail.com>
Date: Tue, 6 Jul 2021 00:45:41 +0300
Subject: [PATCH] ufunc_object: pass args by reference

---
 numpy/core/src/umath/ufunc_object.c | 40 +++++++++++++++++++----------
 1 file changed, 26 insertions(+), 14 deletions(-)

diff --git a/numpy/core/src/umath/ufunc_object.c b/numpy/core/src/umath/ufunc_object.c
index 0644a28c0..e5d08a0b6 100644
--- a/numpy/core/src/umath/ufunc_object.c
+++ b/numpy/core/src/umath/ufunc_object.c
@@ -272,7 +272,7 @@ _get_output_array_method(PyObject *obj, PyObject *method,
  * should just have PyArray_Return called.
  */
 static void
-_find_array_prepare(ufunc_full_args args,
+_find_array_prepare(ufunc_full_args *args,
                     PyObject **output_prep, int nout)
 {
     int i;
@@ -282,7 +282,7 @@ _find_array_prepare(ufunc_full_args args,
      * Determine the prepping function given by the input arrays
      * (could be NULL).
      */
-    prep = _find_array_method(args.in, npy_um_str_array_prepare);
+    prep = _find_array_method(args->in, npy_um_str_array_prepare);
     /*
      * For all the output arrays decide what to do.
      *
@@ -295,7 +295,7 @@ _find_array_prepare(ufunc_full_args args,
      * exact ndarray so that no PyArray_Return is
      * done in that case.
      */
-    if (args.out == NULL) {
+    if (args->out == NULL) {
         for (i = 0; i < nout; i++) {
             Py_XINCREF(prep);
             output_prep[i] = prep;
@@ -304,7 +304,7 @@ _find_array_prepare(ufunc_full_args args,
     else {
         for (i = 0; i < nout; i++) {
             output_prep[i] = _get_output_array_method(
-                PyTuple_GET_ITEM(args.out, i), npy_um_str_array_prepare, prep);
+                PyTuple_GET_ITEM(args->out, i), npy_um_str_array_prepare, prep);
         }
     }
     Py_XDECREF(prep);
@@ -401,7 +401,7 @@ _ufunc_setup_flags(PyUFuncObject *ufunc, npy_uint32 op_in_flags,
  * should just have PyArray_Return called.
  */
 static void
-_find_array_wrap(ufunc_full_args args, npy_bool subok,
+_find_array_wrap(ufunc_full_args *args, npy_bool subok,
                  PyObject **output_wrap, int nin, int nout)
 {
     int i;
@@ -419,7 +419,7 @@ _find_array_wrap(ufunc_full_args args, npy_bool subok,
      * Determine the wrapping function given by the input arrays
      * (could be NULL).
      */
-    wrap = _find_array_method(args.in, npy_um_str_array_wrap);
+    wrap = _find_array_method(args->in, npy_um_str_array_wrap);
 
     /*
      * For all the output arrays decide what to do.
@@ -434,7 +434,7 @@ _find_array_wrap(ufunc_full_args args, npy_bool subok,
      * done in that case.
      */
 handle_out:
-    if (args.out == NULL) {
+    if (args->out == NULL) {
         for (i = 0; i < nout; i++) {
             Py_XINCREF(wrap);
             output_wrap[i] = wrap;
@@ -443,7 +443,7 @@ handle_out:
     else {
         for (i = 0; i < nout; i++) {
             output_wrap[i] = _get_output_array_method(
-                PyTuple_GET_ITEM(args.out, i), npy_um_str_array_wrap, wrap);
+                PyTuple_GET_ITEM(args->out, i), npy_um_str_array_wrap, wrap);
         }
     }
 
@@ -910,7 +910,7 @@ _wheremask_converter(PyObject *obj, PyArrayObject **wheremask)
  */
 static int
 convert_ufunc_arguments(PyUFuncObject *ufunc,
-        ufunc_full_args full_args, PyArrayObject **out_op,
+        ufunc_full_args *full_args, PyArrayObject **out_op,
         PyObject *order_obj, NPY_ORDER *out_order,
         PyObject *casting_obj, NPY_CASTING *out_casting,
         PyObject *subok_obj, npy_bool *out_subok,
@@ -924,7 +924,7 @@ convert_ufunc_arguments(PyUFuncObject *ufunc,
 
     /* Convert and fill in input arguments */
     for (int i = 0; i < nin; i++) {
-        obj = PyTuple_GET_ITEM(full_args.in, i);
+        obj = PyTuple_GET_ITEM(full_args->in, i);
 
         if (PyArray_Check(obj)) {
             PyArrayObject *obj_a = (PyArrayObject *)obj;
@@ -941,9 +941,9 @@ convert_ufunc_arguments(PyUFuncObject *ufunc,
     }
 
     /* Convert and fill in output arguments */
-    if (full_args.out != NULL) {
+    if (full_args->out != NULL) {
         for (int i = 0; i < nout; i++) {
-            obj = PyTuple_GET_ITEM(full_args.out, i);
+            obj = PyTuple_GET_ITEM(full_args->out, i);
             if (_set_out_array(obj, out_op + i + nin) < 0) {
                 goto fail;
             }
@@ -4872,7 +4872,7 @@ ufunc_generic_fastcall(PyUFuncObject *ufunc,
     npy_bool subok = NPY_TRUE;
     int keepdims = -1;  /* We need to know if it was passed */
     PyArrayObject *wheremask = NULL;
-    if (convert_ufunc_arguments(ufunc, full_args, operands,
+    if (convert_ufunc_arguments(ufunc, &full_args, operands,
             order_obj, &order,
             casting_obj, &casting,
             subok_obj, &subok,
@@ -4944,7 +4944,19 @@ ufunc_generic_fastcall(PyUFuncObject *ufunc,
     }
 
     Py_XDECREF(typetup);
-    Py_XDECREF(full_args.in);
+    PyObject* result = NULL;
+    if (full_args.in == NULL) {
+        if (PyErr_Occurred() == NULL) {
+            PyErr_SetString(PyExc_RuntimeError,
+                "got NULL for full_args.in 4808");
+        }
+    }
+    else {
+        /* The following steals the references to the outputs: */
+        result = replace_with_wrapped_result_and_return(ufunc,
+            &full_args, subok, operands + nin);
+        Py_XDECREF(full_args.in);
+    }
     Py_XDECREF(full_args.out);
     if (ufunc->nout == 1) {
         return retobj[0];
-- 
2.31.1.windows.1

